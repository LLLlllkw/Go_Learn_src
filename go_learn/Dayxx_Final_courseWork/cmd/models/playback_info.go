// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PlaybackInfo playback info
//
// swagger:model PlaybackInfo
type PlaybackInfo struct {

	// 新回放下载地址的过期时间(unix 时间戳(毫秒))
	// Example: 1548507047292
	Expire int64 `json:"expire,omitempty"`

	// 回放视频 ID
	// Example: 7210000
	// Required: true
	SessionID *string `json:"sessionId"`

	//  回放状态信息: <br> sessionNotExist 课程不存在 <br> sessionNotFinish 课程正在上课 <br> playbackNotGenerated 回放还未生成, 包括需要重新生成, 还未生成 <br> playbackFailedGenerated 回放生成失败, 包括音频错误等各种错误情况 <br> playbackSuccessGenerated 回放生成成功, 存在下载地址, 视频大小 <br> playbackNotVideo 老回放, 只有视频地址 没有下载地址
	// Example: playbackSuccessGenerated
	// Enum: [sessionNotExist sessionNotFinish playbackNotGenerated playbackFailedGenerated playbackSuccessGenerated playbackNotVideo]
	Status *string `json:"status,omitempty"`

	// 新回放的文件大小(单位: byte)
	// Example: 1026323
	VideoSize *int64 `json:"videoSize,omitempty"`

	// 新回放的下载地址
	// Example: http://yx-fudao.ks3-cn-beijing.ksyun.com/testreplayer_data/7210000/7210000.mp4?Expires=1548152332\u0026AWSAccessKeyId=AKLT6GLT4mf1RoiAY5DCcsd_3Q\u0026Signature=zXSJNkX9C3ovtmPYwF3Y2fNcXdY%3D
	VideoURL string `json:"videoUrl,omitempty"`

	// 旧回放的直接播放地址
	// Example: testhfsfd-replayer.haofenshu.com/entry?sid=7210000
	WebURL string `json:"webUrl,omitempty"`
}

// Validate validates this playback info
func (m *PlaybackInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSessionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PlaybackInfo) validateSessionID(formats strfmt.Registry) error {

	if err := validate.Required("sessionId", "body", m.SessionID); err != nil {
		return err
	}

	return nil
}

var playbackInfoTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["sessionNotExist","sessionNotFinish","playbackNotGenerated","playbackFailedGenerated","playbackSuccessGenerated","playbackNotVideo"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		playbackInfoTypeStatusPropEnum = append(playbackInfoTypeStatusPropEnum, v)
	}
}

const (

	// PlaybackInfoStatusSessionNotExist captures enum value "sessionNotExist"
	PlaybackInfoStatusSessionNotExist string = "sessionNotExist"

	// PlaybackInfoStatusSessionNotFinish captures enum value "sessionNotFinish"
	PlaybackInfoStatusSessionNotFinish string = "sessionNotFinish"

	// PlaybackInfoStatusPlaybackNotGenerated captures enum value "playbackNotGenerated"
	PlaybackInfoStatusPlaybackNotGenerated string = "playbackNotGenerated"

	// PlaybackInfoStatusPlaybackFailedGenerated captures enum value "playbackFailedGenerated"
	PlaybackInfoStatusPlaybackFailedGenerated string = "playbackFailedGenerated"

	// PlaybackInfoStatusPlaybackSuccessGenerated captures enum value "playbackSuccessGenerated"
	PlaybackInfoStatusPlaybackSuccessGenerated string = "playbackSuccessGenerated"

	// PlaybackInfoStatusPlaybackNotVideo captures enum value "playbackNotVideo"
	PlaybackInfoStatusPlaybackNotVideo string = "playbackNotVideo"
)

// prop value enum
func (m *PlaybackInfo) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, playbackInfoTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PlaybackInfo) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this playback info based on context it is used
func (m *PlaybackInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PlaybackInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PlaybackInfo) UnmarshalBinary(b []byte) error {
	var res PlaybackInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
